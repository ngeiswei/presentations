\documentclass[aspectratio=169]{beamer}

\usepackage{beamerthemesplit}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{cancel}
\usepackage{bussproofs}
\usepackage{graphicx}

% For ⩘ and ⩗ (requires the LuaLaTeX engine)
\usepackage{unicode-math}
\setmathfont{Stix Two Math}

% For highlighting MeTTa code
\usepackage{listings}
\usepackage{color}
\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
\lstset{ %
  backgroundcolor=\color{white},   % choose the background color
  basicstyle=\tiny,                % size of fonts used for the code
  breaklines=true,                 % automatic line breaking only at whitespace
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  keywordstyle=\color{blue},       % keyword style
  stringstyle=\color{mymauve},     % string literal style
}

\makeatletter
\newcommand{\verytiny}{\@setfontsize{\srcsize}{3.5pt}{3.5pt}}
\makeatother

\makeatletter
\newcommand{\reallytiny}{\@setfontsize{\srcsize}{2pt}{2pt}}
\makeatother

\mode<presentation>
{
  \usetheme{AnnArbor}
  \usecolortheme{crane}
}

\usepackage[english]{babel}
%% \usepackage[latin1]{inputenc}
\usepackage{times}
\usepackage[T1]{fontenc}

\title{Meta-Reasoning in MeTTa}

\author{Nil Geisweiller}

\institute[SingularityNET OpenCog Foundations]
{
  \begin{center}
    %% \includegraphics[scale=0.1]{pics/trueagi-logo-small.png}\\
    \includegraphics[scale=0.2]{pics/snet-logo.png}\\[1cm]
    Artificial Intelligence and Theorem Proving 2024 (AITP-24)
  \end{center}
}

\date[AITP-24]

\begin{document}

\lstset{language=Lisp}

\begin{frame}
  \maketitle
\end{frame}

\section{Introduction}

\subsection{SingularityNET: AI service composition}

\begin{frame}
  %% <BEGIN-SPEECH> Let me briefly introduce myself, I'm Nil Geisweiller,
  %% I work at the SingularityNET Foundation, I do a lot of AI, though
  %% I'm mostly interested in reasoning.  So more specifically why do I
  %% care about automated theorem proving, there are several reasons, but
  %% an important one is because at the SingularityNET Foundation we
  %% offer a market place of AI services and the ability to automatically
  %% connect AI services together, and so if you view AI services as
  %% functions, and their types as specifications, then synthesizing
  %% compositions of AI services is identical to doing theorem
  %% proving. <END-SPEECH>

  \includegraphics[scale=0.3]{pics/AI-Domain-Specific-Language-DSL-Image.jpg}
  %% NEXT: add zoomed out proof tree of (-> (SongIn "English") (SongIn "Chinese"))
\end{frame}

\subsection{Meta-reasoning}

\begin{frame}[fragile]
  %% <BEGIN-SPEECH> My presentation about meta-reasoning, I'm not here to
  %% show you my great results, cause I have none, I'm here to sell you
  %% two things:

  %% 1. MeTTa, a programming language that we're developing at
  %% SingularityNET.

  %% 2. The probably old idea of meta-reasoning, which, as I mean it, is
  %% to reframe the process of learning heuristics to guide reasoning as
  %% itself a reasoning process.

  %% The first time I encountered that idea of meta-reasoning was in the
  %% paper of Juergen Schimdhubber on the Goedel machine.  Not saying it
  %% is the first it appeared on this world, but it was the first time I
  %% encountered it.

  %% I'm going to recall briefly what is a Goedel machine.  So, very
  %% early on, as early as he was a student Juergen was obsessed with
  %% the idea of intelligence bootstrapping.  So he was wondering,
  %% let's say I have a machine that is trying to learn something, say
  %% learn how to drive, but learning is difficult, you've got all
  %% kind of parameters to tune to do that efficient.  So, the natural
  %% idea is to add a another machine on that top of that learner that
  %% would learn how to tune those parameters, but that itself is a
  %% difficult problem, so you may need to add another machine on top
  %% of that other machine, etc, but then it goes on to infinity.  So
  %% after many years, Juergen did find a solution to that problem
  %% combining the following three ideas:

  %% 1. Let's fuse all these machines into one.

  %% 2. Let's have the action set not just about the external world, such
  %% as driving a car, but also about the internal world, specifically
  %% actions to rewrite the content of any memory cell of the machine.

  %% 3. And the third and crucial idea is: only allow actions to get
  %% triggered if we have a mathematical proof that it is indeed a good
  %% idea.

  %% And so that last idea is what I'm trying to realize in the
  %% context of guiding automated theorem proving, specifically given
  %% a theorem prover facing all different paths that can be explored
  %% to find a proof, my system only allows to pursue the paths that
  %% have been mathematically proven to be worth pursuing.  So the
  %% pruner is itself a theorem prover.

  %% <END-SPEECH>

  \begin{columns}[T]
    \begin{column}{2cm}%\column{5cm}
    \only<1>{\includegraphics[scale=0.3]{pics/computer-driving.png}}
    \only<2>{\includegraphics[scale=0.3]{pics/meta-computer-driving.png}}
    \only<3>{\includegraphics[scale=0.3]{pics/meta-meta-computer-driving.png}}
    \only<4->{\includegraphics[scale=0.3]{pics/inf-computer-driving.png}}
    \end{column}

    \vrule{}

    \begin{column}{8cm}
      \visible<5->{G\"odel Machine \emph{(J\"urgen Schmidhuber, 2003)}}
      \begin{itemize}
      \item<6-> Fuse all machines into one.
      \item<7-> Internal actions to action space.
      \item<8-> Mathematical proof $\Rightarrow$ trigger action.
      \end{itemize}
      \begin{center}
        \only<6>{\includegraphics[scale=0.3]{pics/goedel-machine1.png}}
        \only<7>{\includegraphics[scale=0.3]{pics/goedel-machine2.png}}
        \only<8>{\includegraphics[scale=0.3]{pics/goedel-machine3.png}}
      \end{center}
    \end{column}
  \end{columns}

\end{frame}

\section{MeTTa: Meta Type Talk}

\subsection{Functional Logic Programming}

\begin{frame}[fragile]
  %% <BEGIN-SPEECH> In order to show you that in more detail I need to
  %% explain to you what is MeTTa, the programming language I've used to
  %% carry out these experiments. <END-SPEECH>

  \frametitle{MeTTa: Meta Type Talk}

  \begin{columns}

    \column{7cm}
    \begin{itemize}
    \item Functional and logic programming
    \item Non-determinism (like Curry)
    \item Unification (like Prolog)
    \item Gradual typing
    \item Self-modifiable
    \item Concurrency
    \item Scalable
    \end{itemize}

    \column{7cm}

    \begin{lstlisting}
      ;; Bit strings
      (= (bits Z) Nil)
      (= (bits (S $k)) (Cons 0 (bits $k)))
      (= (bits (S $k)) (Cons 1 (bits $k)))

      ;; Generate all 3-bit strings
      !(bits (S (S (S Z))))
    \end{lstlisting}

    \begin{center}
      $\Downarrow$
    \end{center}

    \begin{lstlisting}
      [(Cons 0 (Cons 0 (Cons 0 Nil)))
       (Cons 0 (Cons 0 (Cons 1 Nil)))
       (Cons 0 (Cons 1 (Cons 0 Nil)))
       (Cons 0 (Cons 1 (Cons 1 Nil)))
       (Cons 1 (Cons 0 (Cons 0 Nil)))
       (Cons 1 (Cons 0 (Cons 1 Nil)))
       (Cons 1 (Cons 1 (Cons 0 Nil)))
       (Cons 1 (Cons 1 (Cons 1 Nil)))]
    \end{lstlisting}

  \end{columns}

\end{frame}

\begin{frame}[fragile]
  %% <BEGIN-SPEECH> In order to show you that in more detail I need to
  %% explain to you what is MeTTa, the programming language I've used to
  %% carry out these experiments. <END-SPEECH>

  \frametitle{MeTTa: Meta Type Talk}

  \begin{columns}

    \column{7cm}
    \begin{itemize}
    \item Functional and logic programming
    \item Non-determinism (like Curry)
    \item Unification (like Prolog)
    \item Gradual typing
    \item Self-modifiable
    \item Concurrency
    \item Scalable
    \end{itemize}

    \column{7cm}

    \begin{lstlisting}
      ;; Bit strings
      (= (bits Z) Nil)
      (= (bits (S $k)) (Cons 0 (bits $k)))
      (= (bits (S $k)) (Cons 1 (bits $k)))

      ;; Generate all 3-bit strings
      ;; !(bits (S (S (S Z))))
      !(bits ($x ($y ($z Z))))
    \end{lstlisting}

    \begin{center}
      $\Downarrow$
    \end{center}

    \begin{lstlisting}
      [(Cons 0 (Cons 0 (Cons 0 Nil)))
       (Cons 0 (Cons 0 (Cons 1 Nil)))
       (Cons 0 (Cons 1 (Cons 0 Nil)))
       (Cons 0 (Cons 1 (Cons 1 Nil)))
       (Cons 1 (Cons 0 (Cons 0 Nil)))
       (Cons 1 (Cons 0 (Cons 1 Nil)))
       (Cons 1 (Cons 1 (Cons 0 Nil)))
       (Cons 1 (Cons 1 (Cons 1 Nil)))]
    \end{lstlisting}

  \end{columns}

\end{frame}

\begin{frame}[fragile]
  %% <BEGIN-SPEECH> In order to show you that in more detail I need to
  %% explain to you what is MeTTa, the programming language I've used to
  %% carry out these experiments.
  %%
  %% So MeTTa stands for Meta Type Talk, it is a functional logic
  %% programming language.
  %%
  %% It supports non-determinism.  Here's an example of a program that
  %% generates all 3-bit strings by taking advantage of non-determinism.
  %%
  %% It supports full syntactic unification, so if you replace the three
  %% Ss in the call of bits by variables, it will still output the same
  %% thing, because the matching occurs on both sides.
  %%
  %% It supports gradual typing, so you can add type annotations but you
  %% don't have to.  It's not dynamically typed, it is strongly typed,
  %% but in some type checking will occur at run-time not just at
  %% compile time, because...
  %%
  %% It is self-modifiable, so if you wish to remove, add or modify
  %% functions at run-time, you can do it.
  %%
  %% And last but not least it will soon have support for concurrency and
  %% it should scale incredibly well, Adam Vandervost who's here is doing
  %% some very impressive work on that.
  %%
  %% <END-SPEECH>

  \frametitle{MeTTa: Meta Type Talk}

  \begin{columns}

    \column{7cm}
    \begin{itemize}
    \item Functional and logic programming
    \item Non-determinism (like Curry)
    \item Unification (like Prolog)
    \item Gradual typing
    \item Self-modifiable
    \item Concurrency
    \item Scalable
    \end{itemize}

    \column{7cm}

    \begin{lstlisting}
      ;; Bit strings
      (: bits (-> Nat (List Number)))
      (= (bits Z) Nil)
      (= (bits (S $k)) (Cons 0 (bits $k)))
      (= (bits (S $k)) (Cons 1 (bits $k)))

      ;; Generate all 3-bit strings
      ;; !(bits (S (S (S Z))))
      !(bits ($x ($y ($z Z))))
    \end{lstlisting}

    \begin{center}
      $\Downarrow$
    \end{center}

    \begin{lstlisting}
      [(Cons 0 (Cons 0 (Cons 0 Nil)))
       (Cons 0 (Cons 0 (Cons 1 Nil)))
       (Cons 0 (Cons 1 (Cons 0 Nil)))
       (Cons 0 (Cons 1 (Cons 1 Nil)))
       (Cons 1 (Cons 0 (Cons 0 Nil)))
       (Cons 1 (Cons 0 (Cons 1 Nil)))
       (Cons 1 (Cons 1 (Cons 0 Nil)))
       (Cons 1 (Cons 1 (Cons 1 Nil)))]
    \end{lstlisting}

  \end{columns}

\end{frame}

\section{MeTTa example}

\subsection{Backward chainer}

\begin{frame}[fragile]
  \begin{lstlisting}
;; Backward chainer
(= (bc $kb $_ (: $prf $ccln)) (match $kb (: $prf $ccln) (: $prf $ccln)))
(= (bc $kb (S $k) (: ($prfabs $prfarg) $ccln))
   (let* (((: $prfabs (-> $prms $ccln)) (bc $kb $k (: $prfabs (-> $prms $ccln))))
          ((: $prfarg $prms) (bc $kb $k (: $prfarg $prms))))
     (: ($prfabs $prfarg) $ccln)))
  \end{lstlisting}

  \pause

  \begin{lstlisting}
;; Knowledge base
!(bind! &kb (new-space))
!(add-atom &kb (: AK (-> $a (-> $b $a))))
!(add-atom &kb (: AS (-> (-> $a (-> $b $c)) (-> (-> $a $b) (-> $a $c)))))
  \end{lstlisting}

  \pause

  \begin{lstlisting}
;; Query
!(bc &kb (S (S Z)) (: $prf (-> $a $a)))
  \end{lstlisting}

  \pause

  \begin{lstlisting}
;; Results
[(: ((AS AK) AK) (-> $a $a))
 ...]
  \end{lstlisting}

\end{frame}

\subsection{Backward chainer with dependent types and lambda abstraction}

\begin{frame}[fragile]

  \begin{lstlisting}
;; Backward chainer with dependent types and lambda abstraction

;;;;;;;;;;;;;;;;
;; Base cases ;;
;;;;;;;;;;;;;;;;

;; Match the knowledge base
(= (bc $kb $env $idx $_ (: $prf $thrm))
   (match $kb (: $prf $thrm) (: $prf $thrm)))
;; Match the environment
(= (bc $kb $env $idx $_ (: $prf $thrm))
   (match' $env (: $prf $thrm) (: $prf $thrm)))

;;;;;;;;;;;;;;;;;;;;;
;; Recursive steps ;;
;;;;;;;;;;;;;;;;;;;;;

;; Proof application
(= (bc $kb $env $idx (S $k) (: ($prfabs (: $prfarg $prms)) $thrm))
   (let* (((: $prfabs (-> (: $prfarg $prms) $thrm))
           (bc $kb $env $idx $k (: $prfabs (-> (: $prfarg $prms) $thrm))))
          ((: $prfarg $prms)
           (bc $kb $env $idx $k (: $prfarg $prms))))
     (: ($prfabs (: $prfarg $prms)) $thrm)))
;; Proof abstraction
(= (bc $kb $env $idx (S $k) (: (\ $idx $prfbdy) (-> (: $idx $prms) $thrm)))
   (let (: $prfbdy $thrm)
     (bc $kb (Cons (: $idx $prms) $env) (s $idx) $k (: $prfbdy $thrm))
     (: (λ $idx $prfbdy) (-> (: $idx $prms) $thrm))))
  \end{lstlisting}

\end{frame}

\subsection{Prove properties over programs}

\begin{frame}[fragile]

  \begin{lstlisting}
;; Equality is transitive
!(add-atom &kb (: Trans (-> (: $prf1 (=== $x $y))     ; Premise 1
                            (-> (: $prf2 (=== $y $z)) ; Premise 2
                                (=== $x $z)))))       ; Conclusion

;; Equality is symmetric
!(add-atom &kb (: Sym (-> (: $prf (=== $x $y)) ; Premise
                          (=== $y $x))))       ; Conclusion

;; Equality respects function application
!(add-atom &kb (: Cong (-> (: $f (-> (: $_ $a) $b))                 ; Premise 1
                           (-> (: $x $a)                            ; Premise 2
                               (-> (: $x' $a)                       ; Premise 3
                                   (-> (: $prf (=== $x $x'))        ; Premise 4
                                       (=== ($f $x) ($f $x')))))))) ; Conclusion

;; Rule of replacement
!(add-atom &kb (: Replace (-> (: $prf1 (=== $x $x')) ; Premise 1
                              (-> (: $prf2 $x)       ; Premise 2
                                  $x'))))            ; Conclusion

;; Define double
!(add-atom &kb (: double (-> (: $k N) N)))
!(add-atom &kb (: double_base (=== (double (: Z N)) Z)))
!(add-atom &kb (: double_rec (-> (: $k N)
                                 (=== (double (: (S (: $k N)) N)) (S (: (S (: (double (: $k N)) N)) N))))))

...
  \end{lstlisting}

\end{frame}

\begin{frame}[fragile]

  \begin{lstlisting}
;; Query: find proof that for any natural k, (double k) is even
!(bc &kb Nil z (fromNumber 11) (: $prf (-> (: $k N) (Even (double (: $k N)))))
  \end{lstlisting}

  %% \pause

  \begin{lstlisting}
;; Results
[(: ((SIN ((Replace ((((Cong Even) Z) (double Z)) (Sym double_base)))))
     (\ z (\ (s z) ((Replace (Sym ((((Cong Even) (double (S z))) (S (S (double z)))) (double_rec z))))
                    (MkEvenSS (s z))))))
     (-> (: $k N) (Even (double (: $k N)))))
 ...]
  \end{lstlisting}

{\verytiny
\begin{verbatim}
                                                                                                                     -(z)
                                                                                                                     N
                                                                                                          -(z)       -(double)
                                                                                                          N          N
                                                                                                          -(S)       -(S)                     -(z)
                                                                                                          N          N                        N
                                                                                 -----------------(Even)  -(double)  -(S)  --------------------------------------(double_rec)
                                                                                 (-> (: $_ N) Type)       N          N     (=== (double (S z)) (S (S (double z))))
                                                                                 --------------------------------------------------------------------------------(Cong)     ----------------(s z)
                                                                                                           (=== (Even (double (S $k))) (Even (S (S (double $k)))))          (Even (double z))
                        -(Z)       -----------------(double_base)                                          ------------------------------------------------------(Sym)  ------------------------(MkEvenSS)
                        N          (=== (double Z) Z)                                                      (=== (Even (S (S (double $k)))) (Even (double (S $k))))      (Even (S (S (double z))))
----------(Even)  -(Z)  -(double)  -----------------(Sym)                           ----------------(s z)  -------------------------------------------------------------------------------------(Replace)
(-> N Type)       N     N          (=== Z (double Z))                               (Even (double z))                (Even (double (S z)))
----------------------------------------------------(Cong)  -------(MkEvenZ)  -(z)  -----------------------------------------------------(\)
          (=== (Even Z) (Even (double Z)))                  (Even Z)          N     (-> (: (s z) (Even (double z))) (Even (double (S z))))
          ---------------------------------------------------------(Replace)  ------------------------------------------------------------------(\)
                    (Even (double Z))                                         (-> (: z N) (-> (: (s z) (Even (double z))) (Even (double (S z)))))
                    ----------------------------------------------------------------------------------------------------------------------------(SIN)
                                                            (-> (: $k N) (Even (double $k)))
\end{verbatim}
}

\end{frame}

\section{Meta-reasoning}

\subsection{Inference control}

\begin{frame}
  NEXT
\end{frame}

\end{document}
